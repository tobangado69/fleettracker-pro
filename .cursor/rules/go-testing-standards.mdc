---
alwaysApply: true
---
# Go Testing Standards

## üß™ Testing Philosophy

### Test-Driven Development
- **Write tests first** - Red, Green, Refactor cycle
- **Test behavior, not implementation** - Focus on what the code does
- **Comprehensive coverage** - Aim for 80%+ coverage on business logic
- **Fast feedback loop** - Tests should run quickly and provide clear feedback

### Testing Pyramid
```
    /\
   /  \     E2E Tests (10%)
  /____\    - Full system tests
 /      \   - User journey tests
/        \  
/          \ Integration Tests (20%)
/            \ - Component interaction tests
/              \ - Database integration tests
/                \
/                  \ Unit Tests (70%)
/                    \ - Function-level tests
/                      \ - Mock external dependencies
```

## üèóÔ∏è Test Organization

### File Structure
```
internal/driver/
‚îú‚îÄ‚îÄ handler.go
‚îú‚îÄ‚îÄ service.go
‚îú‚îÄ‚îÄ service_test.go      # Unit tests for service
‚îú‚îÄ‚îÄ handler_test.go      # Unit tests for handler
‚îú‚îÄ‚îÄ integration_test.go  # Integration tests
‚îî‚îÄ‚îÄ benchmark_test.go    # Benchmark tests
```

### Test Package Organization
```go
// ‚úÖ GOOD: Test in same package for access to private functions
package driver

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestService_CreateDriver(t *testing.T) {
    // Test implementation
}

// ‚úÖ GOOD: Separate package for integration tests
package driver_test

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/tobangado69/fleettracker-pro/backend/internal/driver"
)

func TestService_Integration(t *testing.T) {
    // Integration test implementation
}
```

## üéØ Unit Testing

### Table-Driven Tests
```go
// ‚úÖ Optimal: Comprehensive table-driven tests
func TestUserService_ValidateEmail(t *testing.T) {
    tests := []struct {
        name        string
        email       string
        expectedErr error
    }{
        {
            name:        "valid email",
            email:       "user@example.com",
            expectedErr: nil,
        },
        {
            name:        "invalid email format",
            email:       "invalid-email",
            expectedErr: ErrInvalidEmail,
        },
        {
            name:        "empty email",
            email:       "",
            expectedErr: ErrEmptyEmail,
        },
        {
            name:        "email with spaces",
            email:       " user@example.com ",
            expectedErr: ErrInvalidEmail,
        },
    }
    
    service := NewUserService(nil, nil, slog.Default())
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := service.ValidateEmail(tt.email)
            
            if tt.expectedErr != nil {
                assert.Error(t, err)
                assert.Equal(t, tt.expectedErr, err)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

### Mock Usage
```go
// ‚úÖ Optimal: Using gomock for interface mocking
func TestUserService_CreateUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockRepo := mocks.NewMockUserRepository(ctrl)
    mockCache := mocks.NewMockCache(ctrl)
    logger := slog.Default()
    
    service := NewUserService(mockRepo, mockCache, logger)
    
    req := &CreateUserRequest{
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    expectedUser := &User{
        ID:    "123",
        Name:  req.Name,
        Email: req.Email,
    }
    
    // Setup mock expectations
    mockRepo.EXPECT().
        Create(gomock.Any(), gomock.Any()).
        DoAndReturn(func(ctx context.Context, user *User) error {
            user.ID = "123"
            return nil
        })
    
    mockCache.EXPECT().
        Set(gomock.Any(), "user:123", gomock.Any(), gomock.Any()).
        Return(nil)
    
    // Execute
    user, err := service.CreateUser(context.Background(), req)
    
    // Verify
    require.NoError(t, err)
    assert.Equal(t, expectedUser.ID, user.ID)
    assert.Equal(t, expectedUser.Name, user.Name)
    assert.Equal(t, expectedUser.Email, user.Email)
}
```

### Test Helpers
```go
// ‚úÖ Optimal: Reusable test helpers
func setupTestService() *UserService {
    mockRepo := &mockUserRepository{}
    mockCache := &mockCache{}
    logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelError, // Reduce noise in tests
    }))
    
    return NewUserService(mockRepo, mockCache, logger)
}

func createTestUser(service *UserService) string {
    req := &CreateUserRequest{
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    user, err := service.CreateUser(context.Background(), req)
    if err != nil {
        panic(fmt.Sprintf("Failed to create test user: %v", err))
    }
    
    return user.ID
}

func assertUserEqual(t *testing.T, expected, actual *User) {
    t.Helper()
    assert.Equal(t, expected.ID, actual.ID)
    assert.Equal(t, expected.Name, actual.Name)
    assert.Equal(t, expected.Email, actual.Email)
    assert.Equal(t, expected.CreatedAt, actual.CreatedAt)
}
```

## üîó Integration Testing

### Database Integration Tests
```go
// ‚úÖ Optimal: Real database integration tests
func TestUserService_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    db := setupTestDB(t)
    defer cleanupTestDB(t, db)
    
    cache := setupTestCache(t)
    defer cleanupTestCache(t, cache)
    
    service := NewUserService(db, cache, slog.Default())
    
    t.Run("create and retrieve user", func(t *testing.T) {
        req := &CreateUserRequest{
            Name:  "Integration Test User",
            Email: "integration@example.com",
        }
        
        // Create user
        user, err := service.CreateUser(context.Background(), req)
        require.NoError(t, err)
        assert.NotEmpty(t, user.ID)
        assert.Equal(t, req.Name, user.Name)
        assert.Equal(t, req.Email, user.Email)
        
        // Retrieve user
        retrievedUser, err := service.GetUser(context.Background(), user.ID)
        require.NoError(t, err)
        assertUserEqual(t, user, retrievedUser)
    })
    
    t.Run("update user", func(t *testing.T) {
        userID := createTestUser(service)
        
        updateReq := &UpdateUserRequest{
            Name: "Updated Name",
        }
        
        updatedUser, err := service.UpdateUser(context.Background(), userID, updateReq)
        require.NoError(t, err)
        assert.Equal(t, "Updated Name", updatedUser.Name)
    })
}

func setupTestDB(t *testing.T) *gorm.DB {
    t.Helper()
    
    // Use test database
    dsn := "host=localhost user=test password=test dbname=test_db port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    require.NoError(t, err)
    
    // Run migrations
    err = db.AutoMigrate(&User{}, &Profile{})
    require.NoError(t, err)
    
    return db
}

func cleanupTestDB(t *testing.T, db *gorm.DB) {
    t.Helper()
    
    // Clean up test data
    db.Exec("DELETE FROM profiles")
    db.Exec("DELETE FROM users")
    
    sqlDB, err := db.DB()
    require.NoError(t, err)
    sqlDB.Close()
}
```

### HTTP Integration Tests
```go
// ‚úÖ Optimal: HTTP handler integration tests
func TestUserHandler_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    // Setup test server
    router := setupTestRouter(t)
    server := httptest.NewServer(router)
    defer server.Close()
    
    client := server.Client()
    
    t.Run("create user via HTTP", func(t *testing.T) {
        reqBody := `{
            "name": "HTTP Test User",
            "email": "http@example.com"
        }`
        
        resp, err := client.Post(
            server.URL+"/api/users",
            "application/json",
            strings.NewReader(reqBody),
        )
        require.NoError(t, err)
        defer resp.Body.Close()
        
        assert.Equal(t, http.StatusCreated, resp.StatusCode)
        
        var response struct {
            Success bool `json:"success"`
            Data    struct {
                ID    string `json:"id"`
                Name  string `json:"name"`
                Email string `json:"email"`
            } `json:"data"`
        }
        
        err = json.NewDecoder(resp.Body).Decode(&response)
        require.NoError(t, err)
        
        assert.True(t, response.Success)
        assert.NotEmpty(t, response.Data.ID)
        assert.Equal(t, "HTTP Test User", response.Data.Name)
        assert.Equal(t, "http@example.com", response.Data.Email)
    })
}

func setupTestRouter(t *testing.T) *gin.Engine {
    t.Helper()
    
    gin.SetMode(gin.TestMode)
    router := gin.New()
    
    // Setup test dependencies
    db := setupTestDB(t)
    cache := setupTestCache(t)
    service := NewUserService(db, cache, slog.Default())
    handler := NewUserHandler(service)
    
    // Setup routes
    api := router.Group("/api")
    {
        api.POST("/users", handler.CreateUser)
        api.GET("/users/:id", handler.GetUser)
        api.PUT("/users/:id", handler.UpdateUser)
        api.DELETE("/users/:id", handler.DeleteUser)
    }
    
    return router
}
```

## üöÄ Performance Testing

### Benchmark Tests
```go
// ‚úÖ Optimal: Comprehensive benchmark testing
func BenchmarkUserService_CreateUser(b *testing.B) {
    service := setupBenchmarkService()
    req := &CreateUserRequest{
        Name:  "Benchmark User",
        Email: "benchmark@example.com",
    }
    
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _, err := service.CreateUser(context.Background(), req)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}

func BenchmarkUserService_GetUser(b *testing.B) {
    service := setupBenchmarkService()
    userID := createBenchmarkUser(service)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := service.GetUser(context.Background(), userID)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkUserService_GetUser_Parallel(b *testing.B) {
    service := setupBenchmarkService()
    userID := createBenchmarkUser(service)
    
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _, err := service.GetUser(context.Background(), userID)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}
```

### Load Testing
```go
// ‚úÖ Optimal: Load testing utilities
func TestUserService_LoadTest(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping load test in short mode")
    }
    
    service := setupTestService()
    
    const numGoroutines = 100
    const requestsPerGoroutine = 100
    
    var wg sync.WaitGroup
    errors := make(chan error, numGoroutines*requestsPerGoroutine)
    
    start := time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            
            for j := 0; j < requestsPerGoroutine; j++ {
                req := &CreateUserRequest{
                    Name:  fmt.Sprintf("Load Test User %d-%d", workerID, j),
                    Email: fmt.Sprintf("loadtest%d-%d@example.com", workerID, j),
                }
                
                _, err := service.CreateUser(context.Background(), req)
                if err != nil {
                    errors <- fmt.Errorf("worker %d, request %d: %w", workerID, j, err)
                }
            }
        }(i)
    }
    
    wg.Wait()
    close(errors)
    
    duration := time.Since(start)
    totalRequests := numGoroutines * requestsPerGoroutine
    
    t.Logf("Load test results:")
    t.Logf("  Total requests: %d", totalRequests)
    t.Logf("  Duration: %v", duration)
    t.Logf("  Requests per second: %.2f", float64(totalRequests)/duration.Seconds())
    
    // Check for errors
    var errorCount int
    for err := range errors {
        t.Errorf("Request failed: %v", err)
        errorCount++
    }
    
    if errorCount > 0 {
        t.Fatalf("Load test failed with %d errors (%.2f%% failure rate)", 
            errorCount, float64(errorCount)/float64(totalRequests)*100)
    }
}
```

## üîç Test Utilities

### Test Data Builders
```go
// ‚úÖ Optimal: Test data builders for complex objects
type UserBuilder struct {
    user *User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{
            ID:    generateID(),
            Name:  "Default Name",
            Email: "default@example.com",
        },
    }
}

func (b *UserBuilder) WithName(name string) *UserBuilder {
    b.user.Name = name
    return b
}

func (b *UserBuilder) WithEmail(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) WithID(id string) *UserBuilder {
    b.user.ID = id
    return b
}

func (b *UserBuilder) Build() *User {
    return b.user
}

// Usage in tests
func TestUserService_WithBuilder(t *testing.T) {
    user := NewUserBuilder().
        WithName("Test User").
        WithEmail("test@example.com").
        Build()
    
    // Test with the built user
    assert.Equal(t, "Test User", user.Name)
    assert.Equal(t, "test@example.com", user.Email)
}
```

### Mock Implementations
```go
// ‚úÖ Optimal: Simple mock implementations for testing
type mockUserRepository struct {
    users map[string]*User
    mu    sync.RWMutex
}

func newMockUserRepository() *mockUserRepository {
    return &mockUserRepository{
        users: make(map[string]*User),
    }
}

func (m *mockUserRepository) Create(ctx context.Context, user *User) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if user.ID == "" {
        user.ID = generateID()
    }
    
    m.users[user.ID] = user
    return nil
}

func (m *mockUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    user, exists := m.users[id]
    if !exists {
        return nil, gorm.ErrRecordNotFound
    }
    
    return user, nil
}

func (m *mockUserRepository) Update(ctx context.Context, id string, user *User) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if _, exists := m.users[id]; !exists {
        return gorm.ErrRecordNotFound
    }
    
    m.users[id] = user
    return nil
}

func (m *mockUserRepository) Delete(ctx context.Context, id string) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if _, exists := m.users[id]; !exists {
        return gorm.ErrRecordNotFound
    }
    
    delete(m.users, id)
    return nil
}
```

## üìä Test Coverage

### Coverage Analysis
```bash
# Run tests with coverage
go test -coverprofile=coverage.out ./...

# Generate HTML coverage report
go tool cover -html=coverage.out -o coverage.html

# Check coverage percentage
go tool cover -func=coverage.out
```

### Coverage Goals
- **Business Logic**: 90%+ coverage
- **Handlers**: 80%+ coverage
- **Utilities**: 95%+ coverage
- **Overall**: 80%+ coverage

### Coverage Exclusions
```go
// ‚úÖ GOOD: Exclude generated code and main functions
//go:build !coverage
// +build !coverage

func main() {
    // Main function - exclude from coverage
}

// ‚úÖ GOOD: Exclude error cases that are hard to test
func (s *service) processData(data []byte) error {
    if len(data) == 0 {
        return errors.New("data cannot be empty") // Exclude from coverage
    }
    
    // Main logic here
    return nil
}
```

## üéØ Testing Best Practices

### Test Naming
```go
// ‚úÖ GOOD: Descriptive test names
func TestUserService_CreateUser_WithValidData_ReturnsUser(t *testing.T) {}
func TestUserService_CreateUser_WithInvalidEmail_ReturnsError(t *testing.T) {}
func TestUserService_CreateUser_WithDuplicateEmail_ReturnsError(t *testing.T) {}

// ‚ùå BAD: Vague test names
func TestCreateUser(t *testing.T) {}
func TestUserService(t *testing.T) {}
```

### Test Structure
```go
// ‚úÖ GOOD: Arrange-Act-Assert pattern
func TestUserService_CreateUser(t *testing.T) {
    // Arrange
    service := setupTestService()
    req := &CreateUserRequest{
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    // Act
    user, err := service.CreateUser(context.Background(), req)
    
    // Assert
    require.NoError(t, err)
    assert.NotNil(t, user)
    assert.Equal(t, req.Name, user.Name)
    assert.Equal(t, req.Email, user.Email)
    assert.NotEmpty(t, user.ID)
}
```

### Test Isolation
```go
// ‚úÖ GOOD: Each test is independent
func TestUserService_CreateUser(t *testing.T) {
    service := setupTestService() // Fresh service for each test
    
    // Test implementation
}

func TestUserService_GetUser(t *testing.T) {
    service := setupTestService() // Fresh service for each test
    
    // Test implementation
}
```

## üö® Common Testing Anti-Patterns

### What to Avoid
```go
// ‚ùå BAD: Testing implementation details
func TestUserService_CreateUser(t *testing.T) {
    service := &userService{
        repo: mockRepo,
        // Testing internal fields
    }
    
    // Don't test internal state
    assert.Equal(t, mockRepo, service.repo)
}

// ‚ùå BAD: Overly complex test setup
func TestUserService_CreateUser(t *testing.T) {
    // 50+ lines of setup code
    // Complex mock configuration
    // Multiple dependencies setup
    
    // Actual test is buried
}

// ‚ùå BAD: Testing multiple things in one test
func TestUserService_CreateAndUpdateUser(t *testing.T) {
    // Testing both create and update
    // Should be separate tests
}
```

Remember: **Good tests are fast, reliable, maintainable, and provide clear feedback when they fail.**